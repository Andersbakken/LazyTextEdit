Index: textdocument_p.h
===================================================================
--- textdocument_p.h	(revision 56)
+++ textdocument_p.h	(working copy)
@@ -102,8 +102,9 @@
         documentSize(0),
         saveState(NotSaving), device(0), ownDevice(false), modified(false),
         deviceMode(TextDocument::Sparse), chunkSize(16384),
-        undoRedoStackCurrent(0), modifiedIndex(-1), undoRedoEnabled(true), ignoreUndoRedo(false),
-        hasChunksWithLineNumbers(false), textCodec(0)
+        undoRedoStackCurrent(0), modifiedIndex(-1), undoRedoEnabled(true),
+        ignoreUndoRedo(false), hasChunksWithLineNumbers(false),
+        iterators(0), textCodec(0)
     {
         first = last = new Chunk;
     }
@@ -135,6 +136,7 @@
     bool undoRedoEnabled, ignoreUndoRedo;
 
     bool hasChunksWithLineNumbers;
+    int iterators;
     QTextCodec *textCodec;
 
     void joinLastTwoCommands();
@@ -170,112 +172,4 @@
     void undoRedoCommandFinished(DocumentCommand *cmd);
 };
 
-// should not be kept as a member. Invalidated on inserts/removes
-class TextDocumentIterator
-{
-public:
-    TextDocumentIterator(const TextDocumentPrivate *d, int p)
-        : doc(d), pos(p), convert(false)
-    {
-        Q_ASSERT(doc);
-        chunk = doc->chunkAt(p, &offset);
-        Q_ASSERT(chunk);
-        const int chunkPos = p - offset;
-        chunkData = doc->chunkData(chunk, chunkPos);
-    }
-
-    inline bool hasNext() const
-    {
-        return (chunk->next || chunk->size() > offset + 1);
-    }
-
-    inline bool hasPrevious() const
-    {
-        return (chunk->previous || offset > 0);
-    }
-
-    inline int position() const
-    {
-        return pos;
-    }
-
-    inline QChar current() const
-    {
-        Q_ASSERT(doc);
-        Q_ASSERT(chunk);
-        if (pos == doc->documentSize)
-            return QChar();
-        Q_ASSERT(doc->q->readCharacter(pos) == chunkData.at(offset));
-        return convert ? chunkData.at(offset).toLower() : chunkData.at(offset);
-    }
-
-    inline QChar next()
-    {
-        Q_ASSERT(doc);
-        Q_ASSERT(chunk);
-        ++pos;
-        if (++offset >= chunkData.size()) {
-            offset = 0;
-            chunk = chunk->next;
-            Q_ASSERT(chunk);
-            chunkData = doc->chunkData(chunk, pos);
-        }
-        return current();
-    }
-
-    inline QChar previous()
-    {
-        Q_ASSERT(doc);
-        Q_ASSERT(chunk);
-        Q_ASSERT(hasPrevious());
-        --pos;
-        if (--offset < 0) {
-            chunk = chunk->previous;
-            Q_ASSERT(chunk);
-            chunkData = doc->chunkData(chunk, pos - chunk->size() - 1);
-            offset = chunkData.size() - 1;
-        }
-        return current();
-    }
-
-    enum Direction { Left, Right };
-    inline QChar nextPrev(Direction dir, bool &ok)
-    {
-        if (dir == Left) {
-            if (!hasPrevious()) {
-                ok = false;
-                return QChar();
-            }
-            ok = true;
-            return previous();
-        } else {
-            if (!hasNext()) {
-                ok = false;
-                return QChar();
-            }
-            ok = true;
-            return next();
-        }
-    }
-
-    bool convertToLowerCase() const
-    {
-        return convert;
-    }
-
-    void setConvertToLowerCase(bool on)
-    {
-        convert = on;
-    }
-
-private:
-    const TextDocumentPrivate *doc;
-    int pos;
-    int offset;
-    QString chunkData;
-    Chunk *chunk;
-    bool convert;
-};
-
-
 #endif
Index: textdocument.cpp
===================================================================
--- textdocument.cpp	(revision 62)
+++ textdocument.cpp	(working copy)
@@ -113,6 +113,7 @@
             Chunk *c = new Chunk;
             c->data = ts.read(d->chunkSize);
             d->documentSize += c->data.size();
+            qDebug() << c->data.size() << d->documentSize << device->size();
             if (current) {
                 current->next = c;
                 c->previous = current;
@@ -362,7 +363,7 @@
     const TextDocumentIterator::Direction direction = (flags & FindBackward
                                                        ? TextDocumentIterator::Left
                                                        : TextDocumentIterator::Right);
-    TextDocumentIterator it(d, pos);
+    TextDocumentIterator it(this, pos);
     const QLatin1Char newline('\n');
     int last = pos;
     bool ok = true;
@@ -414,7 +415,7 @@
             word[i] = tmp.at(word.size() - i - 1);
         }
     }
-    TextDocumentIterator it(d, pos);
+    TextDocumentIterator it(this, pos);
     if (!caseSensitive)
         it.setConvertToLowerCase(true);
 
@@ -465,7 +466,7 @@
 
     const bool caseSensitive = flags & FindCaseSensitively;
     const QChar ch = (caseSensitive ? chIn : chIn.toLower());
-    TextDocumentIterator it(d, pos);
+    TextDocumentIterator it(this, pos);
     const TextDocumentIterator::Direction dir = (flags & FindBackward
                                                  ? TextDocumentIterator::Left
                                                  : TextDocumentIterator::Right);
@@ -486,6 +487,7 @@
 
 bool TextDocument::insert(int pos, const QString &string)
 {
+    Q_ASSERT(d->iterators == 0);
     Q_ASSERT(pos >= 0 && pos <= d->documentSize);
     if (string.isEmpty())
         return false;
@@ -604,6 +606,7 @@
 
 void TextDocument::remove(int pos, int size)
 {
+    Q_ASSERT(d->iterators == 0);
     Q_ASSERT(pos >= 0 && pos + size <= d->documentSize);
     Q_ASSERT(size >= 0);
 
@@ -1158,7 +1161,7 @@
 
 QString TextDocumentPrivate::wordAt(int position, int *start) const
 {
-    TextDocumentIterator from(this, position);
+    TextDocumentIterator from(q, position);
     if (!isWord(from.current())) {
         if (start)
             *start = -1;
@@ -1171,7 +1174,7 @@
             break;
         }
     }
-    TextDocumentIterator to(this, position);
+    TextDocumentIterator to(q, position);
     while (to.hasNext() && isWord(to.next())) ;
 
     if (start)
@@ -1182,10 +1185,10 @@
 QString TextDocumentPrivate::paragraphAt(int position, int *start) const
 {
     const QLatin1Char newline('\n');
-    TextDocumentIterator from(this, position);
+    TextDocumentIterator from(q, position);
     while (from.hasPrevious() && from.previous() != newline)
         ;
-    TextDocumentIterator to(this, position);
+    TextDocumentIterator to(q, position);
     while (to.hasNext() && to.next() != newline)
         ;
     if (start)
@@ -1284,3 +1287,83 @@
     return ret;
 }
 
+// should not be kept as a member. Invalidated on inserts/removes
+TextDocumentIterator::TextDocumentIterator(TextDocument *document, int p)
+    : doc(document->d), writableDoc(document->d), pos(-1), convert(false)
+{
+    Q_ASSERT(doc);
+    ++document->d->iterators;
+    setPosition(p);
+}
+
+TextDocumentIterator::TextDocumentIterator(const TextDocument *document, int p)
+    : doc(document->d), writableDoc(0), pos(-1), convert(false)
+{
+    Q_ASSERT(doc);
+    setPosition(p);
+}
+
+TextDocumentIterator::~TextDocumentIterator()
+{
+    if (writableDoc)
+        --writableDoc->iterators;
+}
+
+bool TextDocumentIterator::hasNext() const
+{
+    return (chunk->next || chunk->size() > offset + 1);
+}
+
+bool TextDocumentIterator::hasPrevious() const
+{
+    return (chunk->previous || offset > 0);
+}
+
+QChar TextDocumentIterator::current() const
+{
+    Q_ASSERT(doc);
+    Q_ASSERT(chunk);
+    if (pos == doc->documentSize)
+        return QChar();
+    Q_ASSERT(doc->q->readCharacter(pos) == chunkData.at(offset));
+    return convert ? chunkData.at(offset).toLower() : chunkData.at(offset);
+}
+
+QChar TextDocumentIterator::next()
+{
+    Q_ASSERT(doc);
+    Q_ASSERT(chunk);
+    ++pos;
+    if (++offset >= chunkData.size()) {
+        offset = 0;
+        chunk = chunk->next;
+        Q_ASSERT(chunk);
+        chunkData = doc->chunkData(chunk, pos);
+    }
+    return current();
+}
+
+QChar TextDocumentIterator::previous()
+{
+    Q_ASSERT(doc);
+    Q_ASSERT(chunk);
+    Q_ASSERT(hasPrevious());
+    --pos;
+    if (--offset < 0) {
+        chunk = chunk->previous;
+        Q_ASSERT(chunk);
+        chunkData = doc->chunkData(chunk, pos - chunk->size() - 1);
+        offset = chunkData.size() - 1;
+    }
+    return current();
+}
+
+void TextDocumentIterator::setPosition(int p)
+{
+    pos = p;
+    chunk = doc->chunkAt(pos, &offset);
+    Q_ASSERT(chunk);
+    const int chunkPos = pos - offset;
+    chunkData = doc->chunkData(chunk, chunkPos);
+
+}
Index: textdocument.h
===================================================================
--- textdocument.h	(revision 56)
+++ textdocument.h	(working copy)
@@ -141,9 +141,71 @@
     void modificationChanged(bool modified);
 private:
     TextDocumentPrivate *d;
+    friend class TextDocumentIterator;
     friend class TextEdit;
     friend class TextCursor;
     friend class TextDocumentPrivate;
 };
 
+
+// should not be kept as a member. Invalidated on inserts/removes
+class TextDocumentIterator
+{
+    Q_DISABLE_COPY(TextDocumentIterator);
+public:
+    TextDocumentIterator(const TextDocument *d, int p);
+    TextDocumentIterator(TextDocument *d, int p);
+    ~TextDocumentIterator();
+    bool hasNext() const;
+    bool hasPrevious() const;
+    int position() const
+    {
+        return pos;
+    }
+
+    QChar current() const;
+    QChar next();
+    QChar previous();
+    enum Direction { Left, Right };
+    inline QChar nextPrev(Direction dir, bool &ok)
+    {
+        if (dir == Left) {
+            if (!hasPrevious()) {
+                ok = false;
+                return QChar();
+            }
+            ok = true;
+            return previous();
+        } else {
+            if (!hasNext()) {
+                ok = false;
+                return QChar();
+            }
+            ok = true;
+            return next();
+        }
+    }
+
+    bool convertToLowerCase() const
+    {
+        return convert;
+    }
+
+    void setConvertToLowerCase(bool on)
+    {
+        convert = on;
+    }
+
+    void setPosition(int p);
+private:
+    const TextDocumentPrivate *doc;
+    TextDocumentPrivate *writableDoc;
+    int pos;
+    int offset;
+    QString chunkData;
+    Chunk *chunk;
+    bool convert;
+};
+
+
 #endif
